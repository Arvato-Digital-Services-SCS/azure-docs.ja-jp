---
title: フェールオーバーと修正プログラムの適用 - Azure Cache for Redis | Microsoft Docs
description: Azure Cache for Redis のフェールオーバー、修正プログラムの適用、および更新プロセスについて学習します。
services: cache
author: asasine
ms.assetid: 928b9b9c-d64f-4252-884f-af7ba8309af6
ms.service: cache
ms.workload: tbd
ms.tgt_pltfrm: cache
ms.topic: conceptual
ms.date: 10/18/2019
ms.author: adsasine
ms.openlocfilehash: 305511efe86d2b241ef5014d9c3f0501cfd3fbdc
ms.sourcegitcommit: 9a4296c56beca63430fcc8f92e453b2ab068cc62
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/20/2019
ms.locfileid: "72675890"
---
# <a name="failover-and-patching-for-azure-cache-for-redis"></a>Azure Cache for Redis のフェールオーバーと修正プログラムの適用

Azure Cache for Redis サービスでのコンテキストにおけるフェールオーバーを理解することは、回復性の高い優れたクライアント アプリケーションを構築するうえで重要です。 キャッシュ フェールオーバーの一般的な原因は、管理サービスでの Redis バイナリへの修正プログラムの適用によるものです。 この記事では、フェールオーバーの概要、修正プログラムの適用時の動作、回復性の高いクライアント アプリケーションの構築方法について説明します。

## <a name="what-is-a-failover"></a>フェールオーバーとは

### <a name="a-quick-summary-of-our-architecture"></a>アーキテクチャの簡単な概要

キャッシュは、個別のプライベート IP を持つ複数の仮想マシンで構成されます。 各仮想マシンは、ノードとも呼ばれ、1 つの仮想 IP を持つ共有ロード バランサーに接続されます。 各ノードでは Redis サーバー プロセスを実行し、ホスト名と Redis ポートを使用してアクセスできます。 各ノードは、マスターまたはレプリカ ノードと見なされます。 クライアント アプリケーションがキャッシュに接続されると、そのトラフィックはこのロード バランサーを通過し、自動的にマスター ノードにルーティングされます。

Basic キャッシュでは、1 つのノードが常にマスターとなります。 Standard または Premium キャッシュでは、2 つのノードがあり、一方がマスターとして選択され、もう一方がレプリカとなります。 Standard および Premium キャッシュには複数のノードがあるため、1 つのノードが、他のノードで要求の処理が続行されている間、利用できない場合があります。 クラスター化されたキャッシュは多くのシャードで構成され、それぞれに個別のマスター ノードとレプリカ ノードがあります。 1 つのシャードが、他のシャードが使用可能な状態のままになっている間に、ダウンする場合があります。

> [!NOTE]
> Basic キャッシュには複数のノードはなく、可用性に関する SLA は提供されません。 Basic キャッシュは、開発およびテストの目的でのみ推奨されます。 可用性を高めるには、マルチノード デプロイに Standard または Premium キャッシュを使用します。

### <a name="a-failover-explained"></a>フェールオーバーの説明

フェールオーバーは、レプリカ ノードが自身をマスター ノードになるように昇格させ、古いマスター ノードで既存の接続が閉じられたときに発生します。 マスター ノードでは、復帰後に、ロールの変更を通知し、自身をレプリカになるように降格させます。 その後、新しいマスターに接続し、データを同期します。 フェールオーバーが計画される場合とされない場合があります。

計画されたフェールオーバーは、Redis での修正プログラムの適用や OS のアップグレードなどのシステム更新時、およびスケーリングや再起動などの管理操作時に行われます。 ノードには更新について事前に通知されるため、ロールを協調的に交換し、変更のロード バランサーをすばやく更新することができます。 計画されたフェールオーバーは、1 秒未満で完了する必要があります。

計画外のフェールオーバーは、ハードウェア障害、ネットワーク障害、またはマスター ノードのその他の予期しない停止が原因で発生する可能性があります。 レプリカ ノードは自身をマスターに昇格させますが、プロセスには時間がかかります。 レプリカ ノードでは、フェールオーバー プロセスを開始する前に、そのマスター ノードが使用できないことを最初に検出する必要があります。 また、レプリカ ノードでは、過剰なフェールオーバーを回避するために、この計画外の障害が一時的なものでもローカルのものでもないことを確認する必要があります。 この検出の遅延は、計画外のフェールオーバーが通常、10 秒から 15 秒以内に完了することを意味します。

## <a name="how-does-patching-occur"></a>修正プログラムの適用はどのように行われますか?

Azure Cache for Redis サービスでは、最新のプラットフォーム機能と修正プログラムを使用してキャッシュを更新するために定期的にメンテナンスを行います。 キャッシュに修正プログラムを適用するために、サービスでは次の手順に従います。

1. 管理サービスでは、修正プログラムを適用する 1 つのノードを選択します。
1. 選択されたノードがマスター ノードである場合、そのレプリカ ノードでは自身を協調的に昇格させます。 この昇格は、計画されたフェールオーバーと見なされます。
1. 選択されたノードは再起動されて新しい変更が取得され、レプリカ ノードとして復帰します。 レプリカ ノードではマスター ノードに接続し、データを同期します。
1. データの同期が完了すると、残りのノードに対して修正プログラムの適用プロセスが繰り返されます。

修正プログラムの適用は計画されたフェールオーバーであるため、レプリカ ノードではマスターになるためにすぐに自身を昇格させ、要求の処理と新しい接続を開始します。 Basic キャッシュにはレプリカ ノードがなく、更新が完了するまで使用できません。 クラスター化されたキャッシュの各シャードには個別に修正プログラムが適用され、別のシャードへの接続は閉じられません。

> [!IMPORTANT]
> データの損失を防ぐために、ノードには一度に 1 つずつ修正プログラムが適用されます。 Basic キャッシュではデータが失われます。 クラスター化されたキャッシュでは、一度に 1 つのシャードに修正プログラムが適用されます。

同じリソー スグループとリージョン内の複数のキャッシュにも、一度に 1 つずつ修正プログラムが適用されます。  異なるリソース グループまたは異なるリージョンにあるキャッシュには、同時に修正プログラムが適用される場合があります。

完全なデータ同期はプロセスが繰り返される前に行われるため、Standard または Premium キャッシュを使用する場合はデータが失われる可能性が低くなります。 データの[エクスポート](cache-how-to-import-export-data.md#export)を使用して、[永続化](cache-how-to-premium-persistence.md)を有効にすることで、データの損失をさらに防ぐことができます。

### <a name="additional-cache-load"></a>追加のキャッシュの負荷

フェールオーバーが発生するたびに、Standard および Premium キャッシュでは、ノード間でデータをレプリケートする必要があります。 このレプリケーションによって、サーバーのメモリと CPU の両方で負荷が増加します。 キャッシュ インスタンスに既に大きな負荷がかかっている場合は、クライアント アプリケーションの待機時間が長くなることがあります。 極端な場合、クライアント アプリケーションでタイムアウト例外を受け取ることがあります。 この追加の負荷の影響を軽減するのに役立つように、キャッシュの `maxmemory-reserved` 設定を[構成](cache-configure.md#memory-policies)します。

## <a name="how-does-a-failover-impact-my-client-application"></a>フェールオーバーはクライアント アプリケーションにどのような影響を与えますか?

クライアント アプリケーションで見られるエラーの数は、フェールオーバー時にその接続で保留されていた操作の数によって異なります。 接続を閉じたノード経由でルーティングされた接続では、エラーが見られます。 多くのクライアント ライブラリでは、タイムアウト例外、接続例外、または接続の切断時のソケット例外など、さまざまな種類のエラーがスローされる可能性があります。 例外の数と種類は、キャッシュで接続が閉じられたときの要求のコード パス内の場所によって異なります。 たとえば、要求を送信しても、フェールオーバーが発生したときに応答を受信していない操作は、タイムアウト例外を取得する可能性があります。 閉じられた接続オブジェクトでの新しい要求では、再接続が正常に行われるまで接続例外を受け取ります。

ほとんどのクライアント ライブラリでは、そのように構成されている場合はキャッシュへの再接続が試行されますが、予期しないバグによってライブラリ オブジェクトが回復不能な状態になることがあります。 事前に構成された時間を超えてエラーが続く場合は、接続オブジェクトを再作成する必要があります。 .NET およびその他のオブジェクト指向言語では、[Lazy\<T\> パターン](https://gist.github.com/JonCole/925630df72be1351b21440625ff2671f#reconnecting-with-lazyt-pattern)を使用することで、アプリケーションを再起動せずに接続を再作成できます。

### <a name="what-should-i-do-in-my-application"></a>アプリケーションで何を行う必要がありますか?

フェールオーバーを完全に回避することはできないため、接続の切断や失敗した要求に対する回復性を確保するためにクライアント アプリケーションを作成する必要があります。 ほとんどのクライアント ライブラリが自動的にキャッシュ エンドポイントに再接続されても、少数のクライアント ライブラリで失敗した要求の再試行が試みられます。 アプリケーションのシナリオによっては、バックオフによる再試行ロジックが理にかなっている場合があります。

クライアント アプリケーションの回復性をテストするには、接続が切断された場合の手動トリガーとして、[再起動](cache-administration.md#reboot)を使用します。 さらに、キャッシュの[更新をスケジュール](cache-administration.md#schedule-updates)し、指定された毎週の時間枠で Redis のランタイム修正プログラムを適用するように、管理サービスに指示することをお勧めします。 これらの時間枠は、通常、潜在的なインシデントを回避するために、クライアント アプリケーションのトラフィックが少ない期間に選択されます。

### <a name="client-network-configuration-changes"></a>クライアント ネットワーク構成の変更

特定のクライアント側のネットワーク構成を変更すると、"接続が使用できません" というエラーが発生することがあります。  クライアント アプリケーションの仮想 IP アドレスをステージング スロットと運用スロット間で交換したり、アプリケーションのインスタンスのサイズ/数をスケーリングしたりすると、1 分以上続かない接続の問題が発生する可能性があります。 クライアント アプリケーションは、Redis に加え、他の外部のネットワーク リソースに接続できなくなる可能性があります。

## <a name="next-steps"></a>次の手順

- キャッシュの[更新をスケジュールする](cache-administration.md#schedule-updates)。
- [再起動](cache-administration.md#reboot)を使用して、アプリケーションの回復性をテストする。
- メモリの予約とポリシーを[構成する](cache-configure.md#memory-policies)。
