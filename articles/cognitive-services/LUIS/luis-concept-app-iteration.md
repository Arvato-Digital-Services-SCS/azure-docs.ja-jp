---
title: 反復的アプリ設計 - LUIS
titleSuffix: Azure Cognitive Services
description: LUIS は、モデル変更、発話の例、公開、エンドポイント クエリからのデータ収集という反復サイクルの中で最も適切に学習します。
services: cognitive-services
author: diberry
manager: nitinme
ms.custom: seodec18
ms.service: cognitive-services
ms.subservice: language-understanding
ms.topic: conceptual
ms.date: 10/25/2019
ms.author: diberry
ms.openlocfilehash: 12a1f2304e4255eb9abd04ab2e2d0726066dd1e6
ms.sourcegitcommit: c22327552d62f88aeaa321189f9b9a631525027c
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/04/2019
ms.locfileid: "73487774"
---
# <a name="authoring-cycles-and-versions"></a>作成サイクルとバージョン

LUIS アプリは、次の反復サイクルでの学習が最適です。

* 新しいバージョンを作成する
* アプリのスキーマを編集する
    * 発話の例が含まれる意図
    * entities
    * features
* トレーニング
* テスト
* [発行]
    * アクティブ ラーニングの予測エンドポイントでテストする
* エンドポイント クエリからデータを収集する

![作成サイクル](./media/luis-concept-app-iteration/iteration.png)

## <a name="building-a-luis-schema"></a>LUIS スキーマの構築

このアプリのスキーマの目的は、ユーザーが求めていること (意図) と、回答の決定に役立つ詳細情報 (エンティティ) が質問のどの部分に示されているのかを定義することです。 

関連性のある単語およびフレーズと一般的な語順を決定するためには、アプリのスキーマがアプリのドメインに固有である必要があります。 

発話の例は、アプリで実行時に取得されることが予想されるユーザー入力を表します。 

スキーマには意図が必要であり、エンティティが_含まれている必要があります_。 

### <a name="example-schema-of-intents"></a>意図のスキーマの例

最も一般的なスキーマが意図によって編成された意図のスキーマです。 この種類のスキーマは、LUIS に依存してユーザーの意図を決定します。 

このスキーマの種類には、LUIS が意図を決定するのに役立つエンティティが含まれている可能性があります。 たとえば、出荷エンティティ (意図の記述子として) を使用すると、LUIS が出荷の意図を決定できます。 

### <a name="example-schema-of-entities"></a>エンティティのスキーマの例

エンティティのスキーマは、発話から抽出されるデータであるエンティティに注目します。 

発話の意図は、クライアント アプリケーションにとってはあまり重要ではありません。 

エンティティのスキーマを編成する場合、すべての発話の例を None (なし) の意図に追加する方法が一般的です。 

### <a name="example-of-a-mixed-schema"></a>混合スキーマの例

最も強力で成熟度の高いスキーマが、すべてのエンティティと機能を備えた意図のスキーマです。 このスキーマは意図またはエンティティのスキーマのどちらかで開始し、その両方の概念が含まれるように拡大することができます。これは、クライアント アプリケーションでそのような情報が必要とされるためです。 

## <a name="add-example-utterances-to-intents"></a>発話の例を意図に追加する

LUIS では各**意図**での発話の例が必要です。 発話の例には、発話が意味する意図を決定できるくらい十分なバリエーションの単語の選択と語順が必要になります。 

> [!CAUTION]
> 発話の例はまとめて追加しないでください。 15 から 30 くらいの、具体的で異なる例から始めてください。 

各発話例には、**エンティティ**で設計されラベル付けされた、**抽出に必要なデータ**がすべて含まれている必要があります。 

|主な要素|目的|
|--|--|
|Intent|ユーザーの発話を単一の意図、つまりアクションに**分類**します。 例は、`BookFlight` や `GetWeather` のようになります。|
|エンティティ|意図を完了するために必要なデータを、発話から**抽出**します。 例としては、旅行の日付と時刻、場所などがあります。|

発話を **None** の意図に割り当てることによって、アプリのドメインに無関係な発話を無視するように LUIS アプリを設計します。 

## <a name="test-and-train-your-app"></a>アプリのテストとトレーニング

必要なエンティティがラベル付けされている 15 から 30 のさまざまな発話の例を意図ごとに用意したら、テストして[トレーニング](luis-how-to-train.md)する必要があります。 

## <a name="publish-to-a-prediction-endpoint"></a>予測エンドポイントに公開する

アプリを必要な[予測エンドポイント領域](luis-reference-regions.md)で利用できるように公開します。 

## <a name="test-your-published-app"></a>発行したアプリのテスト

HTTPS 予測エンドポイントから公開した LUIS アプリをテストできます。 予測エンドポイントからテストすると、LUIS では、信頼度が低い発話を[確認](luis-how-to-review-endpoint-utterances.md)用に選択できます。  

## <a name="create-a-new-version-for-each-cycle"></a>サイクルごとに新しいバージョンを作成する

LUIS のバージョンは、従来のプログラミングのバージョンと似ています。 各バージョンは、アプリのある時点のスナップショットです。 アプリを変更する前に、新しいバージョンを作成してください。 以前のバージョンに戻り、意図と発話を削除し、前の状態に戻してみるとより簡単です。

バージョン ID は、文字、数字、または '.' で構成します。文字数は 10 文字までです。

初期バージョン (0.1) は、既定のアクティブなバージョンです。 

### <a name="begin-by-cloning-an-existing-version"></a>既存のバージョンを複製して開始する

既存のバージョンを複製して、新しいバージョンの始点として使用します。 バージョンを複製すると、新規バージョンが**アクティブ**なバージョンになります。 

### <a name="publishing-slots"></a>発行スロット
ステージング スロットと運用スロットのどちらかに公開します。 スロットごとで、別のバージョンを公開することも、同じバージョンを公開することもできます。 これは、運用に公開する前の変更の確認に役立ち、ボットや他の LUIS 呼び出し元アプリケーションで使用できます。 

トレーニング済みのバージョンは、アプリの[エンドポイント](luis-glossary.md#endpoint)で自動的に利用できるわけではありません。 バージョンをアプリのエンドポイントで利用可能にするには、[公開](luis-how-to-publish-app.md)または再公開する必要があります。 **ステージング**と**運用**に公開できるので、エンドポイントでは 2 つのバージョンのアプリを使用できます。 エンドポイントで使用できるアプリのバージョンがさらに必要な場合は、バージョンをエクスポートして、新しいアプリに再度インポートします。 新しいアプリには別のアプリ ID が付きます。

### <a name="import-and-export-a-version"></a>バージョンのインポートとエクスポート
バージョンは、アプリ レベルでインポートできます。 そのバージョンがアクティブなバージョンになり、アプリ ファイルの `versionId` プロパティではそのバージョン ID が使用されます。 バージョン レベルで既存のアプリにインポートすることもできます。 新規バージョンがアクティブなバージョンになります。 

バージョンは、アプリまたはバージョン レベルでエクスポートできます。 唯一の違いは、アプリ レベルでエクスポートされるバージョンは現在アクティブなバージョンであるのに対して、バージョン レベルでは、 **[[設定]](luis-how-to-manage-versions.md)** ページで任意のバージョンを選択してエクスポートできます。 

エクスポートされたファイルには次が含まれていません。

* 機械学習された情報 (アプリはインポート後に再度トレーニングされるため)
* 共同作成者情報

LUIS アプリのスキーマをバックアップするには、LUIS ポータルからバージョンをエクスポートします。

## <a name="manage-contributor-changes-with-versions-and-apps"></a>バージョンとアプリで共同作成者の変更を管理する

LUIS は、Azure リソースレベルのアクセス許可を提供することで、アプリの共同作成者の概念を提供します。 この概念とバージョン管理を組み合わせることにより、対象を絞ったコラボレーションが実現します。 

アプリの共同作成者の変更を管理するには、次の方法を使用します。

### <a name="manage-multiple-versions-inside-the-same-app"></a>同じアプリ内で複数のバージョンを管理する
まず、各作成者用に、基本バージョンから[複製](luis-how-to-manage-versions.md#clone-a-version)します。 

各作成者は、アプリの自分のバージョンに変更を加えます。 各作成者は自分のモデルに満足したら、新しいバージョンを JSON ファイルにエクスポートします。  

エクスポートされたアプリ、json または .lu ファイルで、変更を比較することができます。 ファイルを結合して、新しいバージョンのファイルを 1 つ作成します。 **versionId** プロパティを変更して、マージされた新しいバージョンを示します。 このバージョンを元のアプリにインポートします。 

この方法に従うと、アクティブなバージョンが 1 つ、ステージング バージョンが 1 つ、公開済みのバージョンが 1 つ存在することになります。 [対話型のテスト ウィンドウ](luis-interactive-test.md)で、アクティブなバージョンの結果を、発行されたバージョン (ステージングまたは運用) と比較することができます。

### <a name="manage-multiple-versions-as-apps"></a>複数のバージョンをアプリとして管理する
基本バージョンを[エクスポート](luis-how-to-manage-versions.md#export-version)します。 各作成者がこのバージョンをインポートします。 アプリをインポートするユーザーが、バージョンの所有者です。 アプリの変更が完了したら、バージョンをエクスポートします。 

エクスポートされたアプリは JSON 形式ファイルなので、変更点を基本のエクスポートと比較することができます。 ファイルを結合して、新しいバージョンの JSON ファイルを 1 つ作成します。 JSON の **versionId** プロパティを変更して、マージされた新しいバージョンを示します。 このバージョンを元のアプリにインポートします。

コラボレーターからの投稿の作成の詳細については、[こちら](luis-how-to-collaborate.md)を参照してください。

## <a name="review-endpoint-utterances-to-begin-the-new-authoring-cycle"></a>エンドポイントの発話を確認して、新しい作成サイクルを開始する

作成サイクルが完了したら、もう一度開始できます。 LUIS によって信頼度が低いとマークされた[予測エンドポイントの発話の確認](luis-how-to-review-endpoint-utterances.md)から開始します。 これらの発話で、予測される正しい意図と、正確で完全なエンティティが抽出されたことを確認します。 変更を確認して同意すると、確認リストが空になります。  

## <a name="next-steps"></a>次の手順

[コラボレーション](luis-concept-keys.md)の概念を学習します。
